(00) S->program id { variable_declaration stmts }
{} //这里是不是应该使用全局变量，将类型传过去？

(01) stmts->stmts1 M stmt
{ backpatch(stmts1.nextlist,M.instr);
  stmts.nextlist = stmt.nextlist; }

(02) stmts->epsilon

(03) stmt->{ stmts }
{ stmt.nextlist = stmts.nextlist; }

(04) stmt->while M1 ( expr ) M2 stmt1
{ backpatch(stmt1.nextlist,M1.instr);
  backpatch(expr.truelist,M2.instr);
  stmt.nextlist = stmt1.nextlist;
  gen('goto' M1.instr); }

(05) stmt->if ( expr ) M stmt1
{ backpatch(expr.truelist ,M.instr);
  stmt.nextlist = merge(expr.falselist,stmt1.nextlist); }

(06) stmt->if ( expr ) M1 stmt1 N else M2 stmt2
{ backpatch(expr.truelist,M1.instr);
  backpatch(expr.falselist,M2.instr);
  temp = merge(stmt1.nextlist,N.nextlist);
  stmt.nextlist = merge(temp,stmt2.nextlist); }

(07) stmt->for ( id in num .. num1 N ) M stmt1
{ t = new Temp();
  gen(t '=' id.addr '+' 1);
  gen(id.addr '=' t);
  temp = nextinstr;
  gen('if' id.addr '<=' num1.value 'goto' M.instr);
  stmt.nextlist = makelist(nextinstr);
  gen('goto _');
  backpatch(N.nextlist,nextinstr);
  gen(id.addr '=' num.value);
  gen('goto' temp); } //这里还是有点搞不懂

(08) stmt->variable = expr ;
{ gen(variable.addr '=' expr.addr);
  top.putNS(variable.lexeme); }

(09) stmt->variable -= expr ;
{ gen(variable.addr '-=' expr.addr);
  top.putNS(variable.lexeme); }

(10) stmt->variable += expr ;
{ gen(variable.addr '+=' expr.addr);
  top.putNS(variable.lexeme); }

(11) stmt->variable *= expr ;
{ gen(variable.addr '*=' expr.addr);
  top.putNS(variable.lexeme); }

(12) stmt->variable /= expr ;
{ gen(variable.addr '/=' expr.addr);
  top.putNS(variable.lexeme); }

(13) stmt->expr ;

(14) variable_declaration -> type null_sign variables ; variable_declaration
(15) variable_declaration -> epsilon
(16) type -> int
(17) type -> float
(18) null_sign -> ?
{ ns = 1; }

(19) null_sign -> epsilon
{ ns = 0; }

(20) variables -> variable , variables1

(21) variables -> variable

(22) variable -> id array
{ top.put(id.lexeme,array.type,offset,ns,array.width);
  offset = offset + array.width; }

(23) array -> [ expr ] array1
{ array.type = array(expr.value,array1.type); }

(24) array -> epsilon
{ array.type = type;
  array.width = width; }

(25) expr->expr + expr
{ expr.addr = new Temp();
  gen(expr.addr '=' expr1.addr '+' expr2.addr);
}

(26) expr->expr - expr
{ expr.addr = new Temp();
  gen(expr.addr '=' expr1.addr '-' expr2.addr);
}

(27) expr->expr * expr
{ expr.addr = new Temp();
  gen(expr.addr '=' expr1.addr '*' expr2.addr);
}

(28) expr->expr / expr
{ expr.addr = new Temp();
  gen(expr.addr '=' expr1.addr '/' expr2.addr);
}

(29) expr->expr ^ factor
{ expr.addr = new Temp();
  gen(expr.addr '=' expr1.addr '^' factor.addr); }

(30) expr->factor
{ expr.addr = factor.addr; }

(31) expr->expr1 < expr2
{ expr.truelist = makelist(nextinstr);
  expr.falselist = makelist(nextinstr + 1);
  gen('if' expr1.addr '<' expr2.addr 'goto _');
  gen('goto _'); }

(32) expr->expr > expr
{ expr.truelist = makelist(nextinstr);
  expr.falselist = makelist(nextinstr + 1);
  gen('if' expr1.addr '>' expr2.addr 'goto _');
  gen('goto _'); }

(33) expr->expr != expr
{ expr.truelist = makelist(nextinstr);
  expr.falselist = makelist(nextinstr + 1);
  gen('if' expr1.addr '!=' expr2.addr 'goto _');
  gen('goto _'); }

(34) expr->expr == expr
{ expr.truelist = makelist(nextinstr);
  expr.falselist = makelist(nextinstr + 1);
  gen('if' expr1.addr '==' expr2.addr 'goto _');
  gen('goto _'); }

(35) expr->expr <= expr
{ expr.truelist = makelist(nextinstr);
  expr.falselist = makelist(nextinstr + 1);
  gen('if' expr1.addr '<=' expr2.addr 'goto _');
  gen('goto _'); }

(36) expr->expr >= expr
{ expr.truelist = makelist(nextinstr);
  expr.falselist = makelist(nextinstr + 1);
  gen('if' expr1.addr '>=' expr2.addr 'goto _');
  gen('goto _'); }

(37) expr->expr1 && M expr2
{ backpatch(expr1.truelist,M.instr);
  expr.truelist = expr2.truelist;
  expr.falselist = merge(expr1.falselist,expr2.falselist); }

(38) expr->expr1 || M expr2
{ backpatch(expr1.falselist,M.instr);
  expr.falselist = expr2.falselist;
  expr.truelist = merge(expr1.truelist,expr2.truelist); }

(39) factor->variable
{ factor.addr = top.get(variable.lexeme); }

(40) factor->num
{ factor.addr = top.get(num.lexeme); }

(41) factor->real
{ factor.addr = top.get(real.lexeme); }

(42) factor->( expr )
{ factor.addr = expr.addr; }

(43) M -> epsilon
{ M.instr = nextinstr; }

(44) N -> epsilon
{ N.nextlist = makelist(nextinstr);
  gen('goto _'); }